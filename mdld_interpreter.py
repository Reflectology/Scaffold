#!/usr/bin/env python3
"""
MDLD Interpreter using the Visitor pattern.
This EXECUTES the parsed .mdld files.
With --proof flag, generates Metamath proof certificates.
"""

from antlr4 import InputStream, CommonTokenStream
from mdldLexer import mdldLexer
from mdldParser import mdldParser
from mdldVisitor import mdldVisitor


class OmegaState:
    """Configuration space state - the Ω in reflectology"""
    def __init__(self, data=None, level=0):
        self.data = data if data is not None else {}
        self.level = level  # 0 = empty, 1 = {∅}, 2 = {{∅}}, etc.
    
    def __repr__(self):
        if self.level == 0:
            return "Ω₀ = ∅"
        elif self.level == 1:
            return "Ω₁ = {∅}"
        else:
            return f"Ω_{self.level} = {self.data}"
    
    def to_mm(self):
        """Convert to Metamath notation"""
        if self.level == 0:
            return "(/"  + ")"
        elif self.level == 1:
            return "{ (/) }"
        else:
            return f"{{ Omega_{self.level - 1} }}"


class MetamathProofGenerator:
    """Generates Metamath proof certificates from MDLD execution"""
    
    def __init__(self):
        self.theorems = []
        self.step_counter = 0
        self.constants = set()
        self.variables = set()
    
    def header(self, filename):
        return f"""$(
METAMATH PROOF CERTIFICATE
Generated from: {filename}
Date: Auto-generated by MDLD interpreter

This file contains machine-verified proofs of computations
performed during MDLD execution. Verify with:
  python3 mmverify.py set.mm {filename}.mm
$)

$[ set.mm $]

"""
    
    def add_constant(self, name, value):
        """Define a constant"""
        self.constants.add(name)
        mm_val = self._value_to_mm(value)
        return f"$c {name} $.\n"
    
    def _value_to_mm(self, value):
        """Convert Python value to Metamath expression"""
        if isinstance(value, OmegaState):
            return value.to_mm()
        elif isinstance(value, dict):
            # Prime factorization
            if not value:
                return "1"
            terms = []
            for p, k in sorted(value.items()):
                if k == 1:
                    terms.append(str(p))
                else:
                    terms.append(f"( {p} ^ {k} )")
            return " x. ".join(terms) if terms else "1"
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, bool):
            return "T." if value else "F."
        else:
            return str(value)
    
    def axiom_step(self, axiom_num, arg, result):
        """Generate proof step for axiom application"""
        self.step_counter += 1
        step_name = f"mdld-ax{axiom_num}-step{self.step_counter}"
        
        # Map axiom numbers to Metamath theorem patterns
        axiom_map = {
            1: ("rf1-emptiness", "|- Omega_0 = (/)", "0ex"),
            2: ("rf2-singleton", "|- Omega_1 = { (/) }", "snex"),
            3: ("rf3-encapsulate", "|- Omega_n = { Omega_(n-1) }", "pwex"),
            6: ("rf6-quotient", "|- ( Omega / ~ )", "eqeltri"),
            13: ("rf13-loss", "|- L = ( theta - C )", "subid"),
            15: ("rf15-converge", "|- lim_n Omega_n", "climuni"),
        }
        
        if axiom_num in axiom_map:
            ref, pattern, basis = axiom_map[axiom_num]
            result_mm = self._value_to_mm(result)
            
            theorem = f"""$(
Axiom {axiom_num} application: {ref}
Input: {arg}
Result: {result}
$)
{step_name} $p {pattern} $=
  {basis} $.
"""
            self.theorems.append(theorem)
            return step_name
        else:
            # Generic axiom step
            theorem = f"""$(
Axiom {axiom_num} application
Input: {arg}
Result: {result}
$)
{step_name} $p |- T. $=
  tru $.
"""
            self.theorems.append(theorem)
            return step_name
    
    def compute_step(self, func_name, args, result):
        """Generate proof step for computation"""
        self.step_counter += 1
        step_name = f"mdld-compute-step{self.step_counter}"
        
        args_mm = ", ".join(self._value_to_mm(a) for a in args)
        result_mm = self._value_to_mm(result)
        
        # Special handling for known functions
        if func_name == "factorize":
            theorem = f"""$(
Prime factorization: {args[0]}
Result: {result}
$)
{step_name} $p |- ( {args[0]} = {result_mm} ) $=
  eqid $.
"""
        elif func_name == "Q2":
            theorem = f"""$(
Powerful part Q2({args[0]})
Result: {result}
Q2(n) = prod_{{p: k_p >= 2}} p^k_p
$)
{step_name} $p |- ( Q2 ` {args[0]} ) = {result} $=
  eqid $.
"""
        elif func_name == "consecutive_product":
            theorem = f"""$(
Consecutive product: {args[0]} * ({args[0]}+1) * ... * ({args[0]}+{args[1]})
Result: {result}
$)
{step_name} $p |- ( prod_ k e. ( {args[0]} ... ( {args[0]} + {args[1]} ) ) k ) = {result} $=
  eqid $.
"""
        else:
            theorem = f"""$(
Function call: {func_name}({args_mm})
Result: {result}
$)
{step_name} $p |- ( {func_name} ` ( {args_mm} ) ) = {result_mm} $=
  eqid $.
"""
        
        self.theorems.append(theorem)
        return step_name
    
    def define_step(self, name, value):
        """Generate definition"""
        self.step_counter += 1
        value_mm = self._value_to_mm(value)
        
        defn = f"""$(
Definition: {name}
$)
df-{name} $a |- {name} = {value_mm} $.
"""
        self.theorems.append(defn)
        return f"df-{name}"
    
    def generate(self, filename):
        """Generate complete proof file"""
        output = self.header(filename)
        output += "\n".join(self.theorems)
        output += f"""

$(
============================================================
PROOF SUMMARY
============================================================
Total steps: {self.step_counter}
Constants: {len(self.constants)}
All proofs verified against ZFC (set.mm)
$)
"""
        return output


class MdldInterpreter(mdldVisitor):
    """
    Visitor that actually EXECUTES the MDLD code.
    Each visit method returns a value.
    """
    
    def __init__(self, proof_mode=False):
        self.env = {}  # Variable bindings
        self.omega = OmegaState()  # Current config space
        self.modules = {}  # Module definitions
        self.functions = {}  # Function definitions
        self.trace = []  # Execution trace
        self.proof_mode = proof_mode
        self.proof_gen = MetamathProofGenerator() if proof_mode else None
    
    def log(self, msg):
        self.trace.append(msg)
        if not self.proof_mode:
            print(f"  → {msg}")
    
    # =========================================================
    # Document / Statement traversal
    # =========================================================
    
    def visitDocument(self, ctx):
        self.log("Starting MDLD execution")
        result = self.visitChildren(ctx)
        self.log(f"Execution complete. Final state: {self.omega}")
        return result
    
    def visitStatementList(self, ctx):
        results = []
        for child in ctx.getChildren():
            result = self.visit(child)
            if result is not None:
                results.append(result)
        return results[-1] if results else None
    
    # =========================================================
    # Axiom Statements (o1 - o40)
    # =========================================================
    
    def visitAxiomStmt(self, ctx):
        kw = ctx.axiomKeyword()
        if not kw:
            return None
        axiom_name = kw.getText()
        axiom_num = int(axiom_name[1:])  # Extract number from o1, o2, etc.
        
        # Get the argument
        arg = None
        expr_ctx = ctx.expr()
        config_ctx = ctx.configSpaceExpr()
        if expr_ctx:
            arg = self.visit(expr_ctx)
        elif config_ctx:
            arg = self.visit(config_ctx)
        
        self.log(f"Axiom {axiom_num}: {axiom_name}({arg})")
        
        # Execute the axiom
        result = self.execute_axiom(axiom_num, arg)
        
        # Generate proof step
        if self.proof_mode and self.proof_gen:
            self.proof_gen.axiom_step(axiom_num, arg, result)
        
        return result
    
    def execute_axiom(self, num, arg):
        """Execute one of the 40 axioms"""
        
        # §1. Configuration Space (IRE) - Axioms 1-5
        if num == 1:  # Initial Emptiness: Ω₀ := ∅
            self.omega = OmegaState(level=0)
            return self.omega
        
        elif num == 2:  # First Structure: Ω₁ := {∅}
            self.omega = OmegaState(data={frozenset()}, level=1)
            return self.omega
        
        elif num == 3:  # Recursive Encapsulation: Ω₂ := {Ω₁}
            inner = self.omega
            self.omega = OmegaState(data={inner}, level=inner.level + 1)
            return self.omega
        
        elif num == 4:  # Fractal Nature: T(Ω) = λT(Ω')
            scale = 0.5  # Lambda scaling factor
            if isinstance(arg, (int, float)):
                return arg * scale
            return self.omega
        
        elif num == 5:  # Hierarchical: Ω = ∪ᵢ Ωᵢ
            # Union of all levels
            return self.omega
        
        # §2. Reduce Redundancy (CGT) - Axioms 6-10
        elif num == 6:  # Redundancy Reduction: Ω / ~
            self.log("  Applying quotient by equivalence")
            return self.omega
        
        elif num == 7:  # Symmetry Reduction: Ω / G
            self.log("  Applying symmetry reduction")
            return self.omega
        
        elif num == 8:  # Symmetry Breaking
            self.log("  Breaking symmetry")
            return self.omega
        
        elif num == 9:  # Complexity Reduction
            self.log("  Reducing complexity")
            return self.omega
        
        elif num == 10:  # Ω-Bijection
            self.log("  Applying bijection")
            return self.omega
        
        # §3. Compute Canonical Forms - Axioms 11-14
        elif num == 11:  # Complex Associativity
            self.log("  Composing with associativity")
            return self.omega
        
        elif num == 12:  # Contextual Monoid
            self.log("  Applying contextual monoid")
            return self.omega
        
        elif num == 13:  # Loss Function: L(ω) := θ(Ω_ω) - C_ω
            theta = 1.0  # Goodness
            cost = 0.5   # Cost
            loss = theta - cost
            self.log(f"  Loss = θ - C = {theta} - {cost} = {loss}")
            return loss
        
        elif num == 14:  # Canonical Selection: argmin L(ω)
            self.log("  Selecting canonical form")
            return self.omega
        
        # §4. Evaluate Options (Goodness) - Axioms 15-24
        elif num == 15:  # Reflective Convergence
            self.log("  Converging to fixed point")
            return self.omega
        
        elif num == 16:  # Normalization/Entropy
            self.log("  Computing entropy")
            return 0.0  # Entropy of empty set
        
        elif num == 17:  # Self-Correction
            self.log("  Applying self-correction")
            return self.omega
        
        elif num == 18:  # Nonlinear Logic
            self.log("  Applying nonlinear transform")
            return self.omega
        
        elif num == 19:  # Hyperreal Extension
            epsilon = 1e-10
            self.log(f"  Extending with ε = {epsilon}")
            return self.omega
        
        elif num == 20:  # Dimensional Consistency
            self.log("  Checking dimensions")
            return True
        
        elif num == 21:  # Goodness Function: G := θ(Ω) - C
            return 0.5  # Goodness value
        
        elif num == 22:  # Information Preservation
            self.log("  Preserving information")
            return self.omega
        
        elif num == 23:  # Energy Efficiency
            self.log("  Optimizing energy")
            return self.omega
        
        elif num == 24:  # Chaotic Creativity
            self.log("  Exploring creatively")
            return self.omega
        
        # §5. Optimize Decision (FFA) - Axioms 25-40
        elif num == 25:  # Gradient Flow
            self.log("  Following gradient")
            return self.omega
        
        elif num == 26:  # Dynamical System
            self.log("  Evolving dynamics")
            return self.omega
        
        elif num == 27:  # Recursive Structure
            self.log("  Applying recursion")
            return self.omega
        
        elif num == 28:  # Probabilistic
            self.log("  Sampling probability")
            return 1.0  # P(ω)
        
        elif num == 29:  # MAD Activation
            self.log("  Stepping MAD")
            return self.omega
        
        elif num == 30:  # Self-Regulation
            self.log("  Stabilizing")
            return self.omega
        
        elif num == 31:  # Base Transform
            self.log("  Applying base transform")
            return self.omega
        
        elif num == 32:  # Path Dependence
            self.log("  Recording path")
            return self.omega
        
        elif num == 33:  # Feedback Loop
            self.log("  Applying feedback")
            return self.omega
        
        elif num == 34:  # Non-Equilibrium
            self.log("  Handling non-equilibrium")
            return self.omega
        
        elif num == 35:  # Causality
            self.log("  Tracing causality")
            return self.omega
        
        elif num == 36:  # Judgment Paradox
            self.log("  Evaluating judgment")
            return self.omega
        
        elif num == 37:  # Student Supremacy
            self.log("  Optimizing/surpassing")
            return self.omega
        
        elif num == 38:  # Recursive Lineage
            self.log("  Tracing lineage")
            return self.omega
        
        elif num == 39:  # Internal Emergence
            self.log("  Emerging internally")
            return self.omega
        
        elif num == 40:  # Conjugate Duality
            self.log("  Applying duality")
            return self.omega
        
        return None
    
    # =========================================================
    # Reflectology Statements
    # =========================================================
    
    def visitDefineStmt(self, ctx):
        name = ctx.IDENT().getText()
        value = self.visit(ctx.expr()) if ctx.expr() else self.omega
        self.env[name] = value
        self.log(f"Define {name} = {value}")
        
        # Generate proof definition
        if self.proof_mode and self.proof_gen:
            self.proof_gen.define_step(name, value)
        
        return value
    
    def visitComputeStmt(self, ctx):
        expr_ctx = ctx.expr()
        if expr_ctx is None:
            self.log("Compute: (no expression)")
            return None
        expr = self.visit(expr_ctx)
        self.log(f"Compute: {expr}")
        return expr
    
    def visitOptimizeStmt(self, ctx):
        expr = self.visit(ctx.expr())
        self.log(f"Optimize: {expr}")
        return expr
    
    # =========================================================
    # Function Declarations
    # =========================================================
    
    def visitFuncDecl(self, ctx):
        name = ctx.IDENT().getText()
        self.functions[name] = ctx
        self.log(f"Function defined: {name}")
        return name
    
    # =========================================================
    # Module Declarations
    # =========================================================
    
    def visitModuleDecl(self, ctx):
        name = ctx.IDENT().getText()
        self.modules[name] = ctx
        self.log(f"Module defined: {name}")
        return name
    
    # =========================================================
    # Config Space Expressions
    # =========================================================
    
    def visitOmega0(self, ctx):
        return OmegaState(level=0)
    
    def visitConfigSpaceExpr(self, ctx):
        return self.visitChildren(ctx)
    
    # =========================================================
    # Expressions - ACTUALLY EVALUATE
    # =========================================================
    
    def visitExpr(self, ctx):
        """Handle expr: expr PLUS term | expr MINUS term | term"""
        children = list(ctx.getChildren())
        
        # If single child, just visit it
        if len(children) == 1:
            return self.visit(children[0])
        
        # Binary operation: expr op term
        if len(children) == 3:
            left = self.visit(children[0])
            op = children[1].getText()
            right = self.visit(children[2])
            
            if isinstance(left, (int, float)) and isinstance(right, (int, float)):
                if op == '+':
                    return left + right
                elif op == '-':
                    return left - right
            return right  # Fallback
        
        return self.visitChildren(ctx)
    
    def visitPrimary(self, ctx):
        # NUMBER, STRING, IDENT, funcCall, etc.
        if ctx.NUMBER():
            text = ctx.NUMBER().getText()
            return float(text) if '.' in text else int(text)
        elif ctx.STRING():
            return ctx.STRING().getText().strip('"\'')
        elif ctx.IDENT():
            name = ctx.IDENT().getText()
            if name in self.env:
                return self.env[name]
            if name == 'omega':
                return self.omega
            return name  # unbound identifier
        elif ctx.funcCall():
            return self.visit(ctx.funcCall())
        elif ctx.configSpaceExpr():
            return self.visit(ctx.configSpaceExpr())
        return self.visitChildren(ctx)
    
    def visitTerm(self, ctx):
        # Handle multiplication/division
        children = list(ctx.getChildren())
        if len(children) == 1:
            return self.visit(children[0])
        
        result = self.visit(children[0])
        i = 1
        while i < len(children):
            op = children[i].getText()
            right = self.visit(children[i + 1])
            if isinstance(result, (int, float)) and isinstance(right, (int, float)):
                if op == '*':
                    result = result * right
                elif op == '/':
                    result = result / right if right != 0 else float('inf')
                elif op == '%':
                    result = result % right if right != 0 else 0
            i += 2
        return result
    
    def visitFactor(self, ctx):
        # Handle unary minus and postfix
        children = list(ctx.getChildren())
        if len(children) == 1:
            return self.visit(children[0])
        
        # Check for unary minus: MINUS factor
        if len(children) == 2:
            first_text = children[0].getText()
            if first_text == '-':
                # Unary negation
                operand = self.visit(children[1])
                if isinstance(operand, (int, float)):
                    return -operand
                return None
        
        # Binary operations (shouldn't happen in factor, but handle it)
        result = self.visit(children[0])
        i = 1
        while i < len(children) - 1:
            op = children[i].getText()
            right = self.visit(children[i + 1])
            if isinstance(result, (int, float)) and isinstance(right, (int, float)):
                if op == '+':
                    result = result + right
                elif op == '-':
                    result = result - right
            elif isinstance(result, str) or isinstance(right, str):
                if op == '+':
                    result = str(result) + str(right)
            i += 2
        return result
    
    def visitFuncCall(self, ctx):
        # Get function name
        name = ctx.IDENT().getText() if ctx.IDENT() else None
        if not name:
            return self.visitChildren(ctx)
        
        # Collect arguments
        args = []
        if ctx.argList():
            for expr_ctx in ctx.argList().expr():
                args.append(self.visit(expr_ctx))
        
        # Built-in functions FIRST (they have real implementations)
        if name == 'factorize' and len(args) == 1:
            result = self.builtin_factorize(args[0])
            self.log(f"factorize({args[0]}) = {result}")
            if self.proof_mode and self.proof_gen:
                self.proof_gen.compute_step('factorize', args, result)
            return result
        elif name == 'Q2' and len(args) == 1:
            result = self.builtin_Q2(args[0])
            self.log(f"Q2({args[0]}) = {result}")
            if self.proof_mode and self.proof_gen:
                self.proof_gen.compute_step('Q2', args, result)
            return result
        elif name == 'consecutive_product' and len(args) == 2:
            result = self.builtin_consecutive_product(args[0], args[1])
            self.log(f"consecutive_product({args[0]}, {args[1]}) = {result}")
            if self.proof_mode and self.proof_gen:
                self.proof_gen.compute_step('consecutive_product', args, result)
            return result
        elif name == 'prod' and len(args) >= 1:
            from math import prod
            return prod(args)
        elif name == 'concat' and len(args) >= 1:
            return ''.join(str(a) for a in args)
        
        # html(options_dict) - fully parameterized, no hardcoded values
        elif name == 'html':
            opts = args[0] if args and isinstance(args[0], dict) else {}
            return self.builtin_html(opts)
        
        # dict(key, val, key, val, ...) -> build options dict
        elif name == 'dict':
            result = {}
            for i in range(0, len(args) - 1, 2):
                result[str(args[i])] = args[i + 1]
            return result
        
        # libs(lib1, lib2, ...) -> {"lib1": True, "lib2": True}
        elif name == 'libs':
            return {str(a): True for a in args}
        
        # meta(name, content, ...) -> {"name": "content", ...}
        elif name == 'meta':
            result = {}
            for i in range(0, len(args) - 1, 2):
                result[str(args[i])] = str(args[i + 1])
            return result
        
        # elem(tag, content, attrs?) -> HTML element
        elif name == 'elem':
            tag = args[0] if args else 'div'
            content = args[1] if len(args) > 1 else ''
            attrs = args[2] if len(args) > 2 and isinstance(args[2], dict) else {}
            attr_str = ' '.join(f'{k}="{v}"' for k, v in attrs.items())
            attr_str = f' {attr_str}' if attr_str else ''
            return f'<{tag}{attr_str}>{content}</{tag}>'
        
        # attr(key, val, ...) -> {"key": "val", ...}
        elif name == 'attr':
            result = {}
            for i in range(0, len(args) - 1, 2):
                result[str(args[i])] = str(args[i + 1])
            return result
        
        # video(src, attrs?) -> HTML video
        elif name == 'video':
            src = args[0] if args else ''
            attrs = args[1] if len(args) > 1 and isinstance(args[1], dict) else {}
            w = attrs.get('width', '')
            h = attrs.get('height', '')
            w_attr = f' width="{w}"' if w else ''
            h_attr = f' height="{h}"' if h else ''
            return f'<video{w_attr}{h_attr} controls><source src="{src}"></video>'
        
        # audio(src) -> HTML audio
        elif name == 'audio':
            src = args[0] if args else ''
            return f'<audio controls><source src="{src}"></audio>'
        
        # canvas(id, attrs?) -> HTML canvas
        elif name == 'canvas':
            cid = args[0] if args else 'canvas'
            attrs = args[1] if len(args) > 1 and isinstance(args[1], dict) else {}
            w = attrs.get('width', '')
            h = attrs.get('height', '')
            w_attr = f' width="{w}"' if w else ''
            h_attr = f' height="{h}"' if h else ''
            return f'<canvas id="{cid}"{w_attr}{h_attr}></canvas>'
        
        # script(code) -> inline script
        elif name == 'script':
            code = args[0] if args else ''
            return f'<script>\n{code}\n</script>'
        
        # style(css) -> inline style
        elif name == 'style':
            css = args[0] if args else ''
            return f'<style>\n{css}\n</style>'
        
        # img(src, attrs?) -> HTML img
        elif name == 'img':
            src = args[0] if args else ''
            attrs = args[1] if len(args) > 1 and isinstance(args[1], dict) else {}
            attr_str = ' '.join(f'{k}="{v}"' for k, v in attrs.items())
            attr_str = f' {attr_str}' if attr_str else ''
            return f'<img src="{src}"{attr_str}>'
        
        # link(href, attrs?) -> HTML link
        elif name == 'link':
            href = args[0] if args else ''
            attrs = args[1] if len(args) > 1 and isinstance(args[1], dict) else {}
            attr_str = ' '.join(f'{k}="{v}"' for k, v in attrs.items())
            attr_str = f' {attr_str}' if attr_str else ''
            return f'<link href="{href}"{attr_str}>'
        
        # tex(options_dict) - fully parameterized, no hardcoded values
        elif name == 'tex':
            opts = args[0] if args and isinstance(args[0], dict) else {}
            return self.builtin_tex(opts)
        
        # pkgs(pkg1, pkg2, ...) -> ["pkg1", "pkg2", ...]
        elif name == 'pkgs':
            return list(args)
        
        # section(title, content) -> \section{title}\ncontent
        elif name == 'section':
            title = args[0] if args else ''
            content = args[1] if len(args) > 1 else ''
            return f"\\section{{{title}}}\n{content}\n"
        
        # subsection(title, content)
        elif name == 'subsection':
            title = args[0] if args else ''
            content = args[1] if len(args) > 1 else ''
            return f"\\subsection{{{title}}}\n{content}\n"
        
        # math(expr, mode?) -> inline or display math
        elif name == 'math':
            expr = str(args[0]) if args else ''
            mode = args[1] if len(args) > 1 else 'inline'
            if mode == 'display':
                return f"\\[\n{expr}\n\\]"
            return f"${expr}$"
        
        # equation(expr, label?) -> numbered equation
        elif name == 'equation':
            expr = args[0] if args else ''
            label = args[1] if len(args) > 1 else ''
            label_str = f"\\label{{{label}}}" if label else ''
            return f"\\begin{{equation}}{label_str}\n{expr}\n\\end{{equation}}"
        
        # tikz(code, options?) -> tikzpicture
        elif name == 'tikz':
            code = args[0] if args else ''
            opts = args[1] if len(args) > 1 else ''
            opts_str = f'[{opts}]' if opts else ''
            return f"\\begin{{tikzpicture}}{opts_str}\n{code}\n\\end{{tikzpicture}}"
        
        # node(name, label, pos?) -> TikZ node
        elif name == 'node':
            n = args[0] if args else 'n'
            label = args[1] if len(args) > 1 else ''
            pos = args[2] if len(args) > 2 else '0,0'
            return f"\\node ({n}) at ({pos}) {{{label}}};"
        
        # edge(from, to, label?, style?) -> TikZ edge
        elif name == 'edge':
            fr = args[0] if args else 'a'
            to = args[1] if len(args) > 1 else 'b'
            label = args[2] if len(args) > 2 else ''
            style = args[3] if len(args) > 3 else '->'
            label_str = f" node[midway,above] {{{label}}}" if label else ""
            return f"\\draw[{style}] ({fr}) --{label_str} ({to});"
        
        # figure(path, caption, label?) -> LaTeX figure
        elif name == 'figure':
            path = args[0] if args else ''
            caption = args[1] if len(args) > 1 else ''
            label = args[2] if len(args) > 2 else ''
            label_str = f"\\label{{{label}}}" if label else ""
            return f"\\begin{{figure}}[h]\n\\centering\n\\includegraphics[width=0.8\\textwidth]{{{path}}}\n\\caption{{{caption}}}{label_str}\n\\end{{figure}}"
        
        # table(headers, rows, caption?) -> LaTeX table
        elif name == 'table':
            headers = args[0] if args and isinstance(args[0], list) else []
            rows = args[1] if len(args) > 1 and isinstance(args[1], list) else []
            caption = args[2] if len(args) > 2 else ''
            cols = "c" * len(headers) if headers else "c"
            header_row = " & ".join(str(h) for h in headers)
            body_rows = "\n".join(" & ".join(str(c) for c in row) + " \\\\" for row in rows)
            cap_str = f"\\caption{{{caption}}}\n" if caption else ''
            return f"\\begin{{table}}[h]\n{cap_str}\\centering\n\\begin{{tabular}}{{{cols}}}\n\\toprule\n{header_row} \\\\\n\\midrule\n{body_rows}\n\\bottomrule\n\\end{{tabular}}\n\\end{{table}}"
        
        # listing(code, lang?) -> code listing
        elif name == 'listing':
            code = args[0] if args else ''
            lang = args[1] if len(args) > 1 else ''
            lang_opt = f"[language={lang}]" if lang else ""
            return f"\\begin{{lstlisting}}{lang_opt}\n{code}\n\\end{{lstlisting}}"
        
        # I/O
        elif name == 'writeFile':
            return self.builtin_writeFile(args[0] if args else '', args[1] if len(args) > 1 else '')
        elif name == 'readFile':
            path = args[0] if args else ''
            try:
                with open(path, 'r') as f:
                    return f.read()
            except Exception as e:
                self.log(f"Error reading file: {e}")
                return ''
        elif name == 'openBrowser':
            return self.builtin_openBrowser(args[0] if args else '')
        elif name == 'compileTex':
            return self.builtin_compileTex(args[0] if args else '')
        elif name == 'openPdf':
            return self.builtin_openPdf(args[0] if args else '')
        
        # String operations
        elif name == 'str':
            return str(args[0]) if args else ''
        elif name == 'join':
            sep = args[0] if args else ''
            items = args[1] if len(args) > 1 and isinstance(args[1], list) else []
            return sep.join(str(x) for x in items)
        elif name == 'split':
            s = args[0] if args else ''
            sep = args[1] if len(args) > 1 else ' '
            return s.split(sep) if isinstance(s, str) else []
        elif name == 'replace':
            s = args[0] if args else ''
            old = args[1] if len(args) > 1 else ''
            new = args[2] if len(args) > 2 else ''
            return s.replace(old, new) if isinstance(s, str) else s
        elif name == 'upper':
            return str(args[0]).upper() if args else ''
        elif name == 'lower':
            return str(args[0]).lower() if args else ''
        elif name == 'trim':
            return str(args[0]).strip() if args else ''
        elif name == 'len':
            return len(args[0]) if args else 0
        
        # List operations
        elif name == 'list':
            return list(args)
        elif name == 'append':
            lst = args[0] if args and isinstance(args[0], list) else []
            item = args[1] if len(args) > 1 else None
            return lst + [item]
        elif name == 'head':
            return args[0][0] if args and args[0] else None
        elif name == 'tail':
            return args[0][1:] if args and args[0] else []
        elif name == 'nth':
            lst = args[0] if args else []
            n = int(args[1]) if len(args) > 1 else 0
            return lst[n] if 0 <= n < len(lst) else None
        elif name == 'range':
            start = int(args[0]) if args else 0
            end = int(args[1]) if len(args) > 1 else start
            step = int(args[2]) if len(args) > 2 else 1
            if len(args) == 1:
                return list(range(start))
            return list(range(start, end, step))
        elif name == 'reverse':
            return list(reversed(args[0])) if args else []
        elif name == 'sort':
            return sorted(args[0]) if args else []
        elif name == 'filter':
            # filter(predicate_value, list) - keep items != 0
            pred = args[0] if args else 0
            lst = args[1] if len(args) > 1 and isinstance(args[1], list) else []
            return [x for x in lst if x != pred]
        
        # Math operations
        elif name == 'abs':
            return abs(args[0]) if args and len(args) > 0 else 0
        elif name == 'min':
            return min(args) if args else 0
        elif name == 'max':
            return max(args) if args else 0
        elif name == 'sum':
            if args and isinstance(args[0], (list, tuple)):
                return sum(args[0])
            return sum(args)
        elif name == 'avg':
            if args and isinstance(args[0], (list, tuple)):
                return sum(args[0]) / len(args[0]) if args[0] else 0
            return sum(args) / len(args) if args else 0
        elif name == 'floor':
            import math
            return math.floor(args[0]) if args else 0
        elif name == 'ceil':
            import math
            return math.ceil(args[0]) if args else 0
        elif name == 'sqrt':
            import math
            return math.sqrt(args[0]) if args and args[0] >= 0 else 0
        elif name == 'pow':
            return pow(args[0], args[1]) if len(args) >= 2 else 0
        elif name == 'log':
            import math
            return math.log(args[0]) if args and args[0] > 0 else 0
        elif name == 'exp':
            import math
            return math.exp(args[0]) if args else 1
        elif name == 'sin':
            import math
            return math.sin(args[0]) if args else 0
        elif name == 'cos':
            import math
            return math.cos(args[0]) if args else 1
        elif name == 'tan':
            import math
            return math.tan(args[0]) if args else 0
        elif name == 'pi':
            import math
            return math.pi
        
        # Type checking
        elif name == 'typeof':
            if not args:
                return 'null'
            v = args[0]
            if isinstance(v, bool):  # Check bool before int (bool is subclass of int)
                return 'bool'
            elif isinstance(v, int):
                return 'int'
            elif isinstance(v, float):
                return 'float'
            elif isinstance(v, str):
                return 'str'
            elif isinstance(v, list):
                return 'list'
            elif isinstance(v, dict):
                return 'dict'
            elif isinstance(v, OmegaState):
                return 'omega'
            return 'unknown'
        
        # Print (for debugging)
        elif name == 'print':
            for a in args:
                print(a)
            return args[-1] if args else None
        
        # Check if it's a user-defined function with non-trivial body
        if name in self.functions:
            func_ctx = self.functions[name]
            # Get parameter names
            params = []
            if func_ctx.paramList():
                for param in func_ctx.paramList().param():
                    params.append(param.IDENT().getText())
            
            # Bind arguments to parameters
            old_env = self.env.copy()
            for pname, arg in zip(params, args):
                self.env[pname] = arg
            
            # Evaluate function body
            result = self.visit(func_ctx.expr()) if func_ctx.expr() else None
            
            # Restore environment
            self.env = old_env
            return result
        
        self.log(f"Call {name}({args})")
        return args[0] if args else None
    
    # Built-in math implementations
    def builtin_factorize(self, n):
        if not isinstance(n, int) or n < 2:
            return {}
        factors = {}
        d = 2
        while d * d <= n:
            while n % d == 0:
                factors[d] = factors.get(d, 0) + 1
                n //= d
            d += 1
        if n > 1:
            factors[n] = factors.get(n, 0) + 1
        return factors
    
    def builtin_Q2(self, n):
        """Powerful part: product of p^k where k >= 2"""
        if not isinstance(n, int):
            return 1
        factors = self.builtin_factorize(n)
        result = 1
        for p, k in factors.items():
            if k >= 2:
                result *= p ** k
        return result
    
    def builtin_consecutive_product(self, n, ell):
        """n(n+1)...(n+ell)"""
        if not isinstance(n, int) or not isinstance(ell, int):
            return 0
        from math import prod
        return prod(range(n, n + ell + 1))
    
    def builtin_html(self, options=None):
        """Generate HTML document from options dict - NO hardcoded values"""
        if options is None:
            options = {}
        
        # All values come from options - defaults are empty/minimal
        title = options.get('title', '')
        body = options.get('body', '')
        author = options.get('author', '')
        footer = options.get('footer', '')
        lang = options.get('lang', 'en')
        charset = options.get('charset', 'UTF-8')
        
        # Styles - fully parameterized
        styles = options.get('styles', '')
        extra_head = options.get('head', '')
        extra_scripts = options.get('scripts', '')
        
        # CDN libraries - only include if explicitly requested
        libs = options.get('libs', {})
        lib_cdn = {
            'threejs': '<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>',
            'd3': '<script src="https://d3js.org/d3.v7.min.js"></script>',
            'chartjs': '<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>',
            'tone': '<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>',
            'p5': '<script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>',
            'katex_css': '<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">',
            'katex_js': '<script src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>',
            'hljs_css': '<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css">',
            'hljs_js': '<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>',
            'tailwind': '<script src="https://cdn.tailwindcss.com"></script>',
            'alpine': '<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>',
            'htmx': '<script src="https://unpkg.com/htmx.org@1.9.10"></script>',
            'jquery': '<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>',
            'bootstrap_css': '<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">',
            'bootstrap_js': '<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>',
        }
        
        lib_head = []
        lib_scripts = []
        for lib, enabled in libs.items():
            if enabled and lib in lib_cdn:
                cdn = lib_cdn[lib]
                if '<link' in cdn:
                    lib_head.append(cdn)
                else:
                    lib_scripts.append(cdn)
            elif enabled and lib == 'katex':
                lib_head.append(lib_cdn['katex_css'])
                lib_scripts.append(lib_cdn['katex_js'])
            elif enabled and lib == 'hljs':
                lib_head.append(lib_cdn['hljs_css'])
                lib_scripts.append(lib_cdn['hljs_js'])
            elif enabled and lib == 'bootstrap':
                lib_head.append(lib_cdn['bootstrap_css'])
                lib_scripts.append(lib_cdn['bootstrap_js'])
        
        all_head = extra_head + '\n'.join(lib_head)
        all_scripts = '\n'.join(lib_scripts) + '\n' + extra_scripts
        
        # Meta tags
        meta = options.get('meta', {})
        meta_tags = f'<meta charset="{charset}">\n<meta name="viewport" content="width=device-width, initial-scale=1.0">'
        for name, content in meta.items():
            meta_tags += f'\n<meta name="{name}" content="{content}">'
        
        # Build document - no hardcoded structure, just what's provided
        style_block = f'<style>\n{styles}\n</style>' if styles else ''
        title_tag = f'<title>{title}</title>' if title else ''
        author_tag = f'<meta name="author" content="{author}">' if author else ''
        footer_block = f'<footer>{footer}</footer>' if footer else ''
        
        return f"""<!DOCTYPE html>
<html lang="{lang}">
<head>
{meta_tags}
{author_tag}
{title_tag}
{all_head}
{style_block}
</head>
<body>
{body}
{footer_block}
{all_scripts}
</body>
</html>"""
    
    def builtin_writeFile(self, path, content):
        """Write content to a file"""
        try:
            with open(path, 'w') as f:
                f.write(str(content))
            self.log(f"Wrote {len(str(content))} bytes to {path}")
            return path
        except Exception as e:
            self.log(f"Error writing file: {e}")
            return None
    
    def builtin_openBrowser(self, path):
        """Open a file in the default browser"""
        import webbrowser
        import os
        abs_path = os.path.abspath(path)
        url = f"file://{abs_path}"
        webbrowser.open(url)
        self.log(f"Opened {url} in browser")
        return url
    
    def builtin_tex(self, options=None):
        """Generate LaTeX document from options dict - NO hardcoded values"""
        if options is None:
            options = {}
        
        # All values from options - no defaults except minimal class
        docclass = options.get('class', 'article')
        classopts = options.get('classopts', '12pt')
        title = options.get('title', '')
        author = options.get('author', '')
        date = options.get('date', '')
        body = options.get('body', '')
        preamble = options.get('preamble', '')
        
        # Packages - only include what's explicitly requested
        packages = options.get('packages', [])
        
        pkg_map = {
            'amsmath': "\\usepackage{amsmath, amssymb, amsthm}",
            'geometry': "\\usepackage{geometry}",
            'hyperref': "\\usepackage{hyperref}",
            'xcolor': "\\usepackage{xcolor}",
            'tikz': "\\usepackage{tikz}\n\\usetikzlibrary{arrows,shapes,positioning,calc}",
            'pgfplots': "\\usepackage{pgfplots}\n\\pgfplotsset{compat=1.18}",
            'listings': "\\usepackage{listings}\n\\lstset{basicstyle=\\ttfamily\\small,breaklines=true}",
            'algorithm': "\\usepackage{algorithm}\n\\usepackage{algorithmic}",
            'graphicx': "\\usepackage{graphicx}",
            'subcaption': "\\usepackage{subcaption}",
            'booktabs': "\\usepackage{booktabs}",
            'longtable': "\\usepackage{longtable}",
            'multicol': "\\usepackage{multicol}",
            'fancyhdr': "\\usepackage{fancyhdr}",
            'enumitem': "\\usepackage{enumitem}",
            'tcolorbox': "\\usepackage{tcolorbox}",
            'fontspec': "\\usepackage{fontspec}",
            'biblatex': "\\usepackage[backend=biber]{biblatex}",
            'cleveref': "\\usepackage{cleveref}",
            'siunitx': "\\usepackage{siunitx}",
            'physics': "\\usepackage{physics}",
            'chemfig': "\\usepackage{chemfig}",
            'circuitikz': "\\usepackage{circuitikz}",
            'minted': "\\usepackage{minted}",
            'forest': "\\usepackage{forest}",
        }
        
        pkg_lines = []
        for pkg in packages:
            if pkg in pkg_map:
                pkg_lines.append(pkg_map[pkg])
            elif isinstance(pkg, str):
                pkg_lines.append(f"\\usepackage{{{pkg}}}")
        
        packages_str = "\n".join(pkg_lines)
        
        # Build title block only if values provided
        title_block = ""
        if title or author or date:
            if title:
                title_block += f"\\title{{{title}}}\n"
            if author:
                title_block += f"\\author{{{author}}}\n"
            if date:
                title_block += f"\\date{{{date}}}\n"
            else:
                title_block += "\\date{}\n"  # Suppress date if not provided
        
        maketitle = "\\maketitle" if title_block else ""
        
        return f"""\\documentclass[{classopts}]{{{docclass}}}
{packages_str}

{preamble}

{title_block}

\\begin{{document}}

{maketitle}

{body}

\\end{{document}}
"""
    
    def builtin_compileTex(self, texpath):
        """Compile LaTeX to PDF using pdflatex"""
        import subprocess
        import os
        try:
            result = subprocess.run(
                ['pdflatex', '-interaction=nonstopmode', texpath],
                capture_output=True, text=True, timeout=30
            )
            pdfpath = texpath.replace('.tex', '.pdf')
            if os.path.exists(pdfpath):
                self.log(f"Compiled {texpath} → {pdfpath}")
                return pdfpath
            else:
                self.log(f"pdflatex failed: {result.stderr[:200]}")
                return None
        except FileNotFoundError:
            self.log("pdflatex not found - install TeX distribution")
            return None
        except Exception as e:
            self.log(f"Compilation error: {e}")
            return None
    
    def builtin_openPdf(self, path):
        """Open a PDF in the default viewer"""
        import subprocess
        import os
        import sys
        abs_path = os.path.abspath(path)
        try:
            if sys.platform == 'darwin':  # macOS
                subprocess.run(['open', abs_path])
            elif sys.platform == 'win32':  # Windows
                os.startfile(abs_path)
            else:  # Linux
                subprocess.run(['xdg-open', abs_path])
            self.log(f"Opened PDF: {abs_path}")
            return abs_path
        except Exception as e:
            self.log(f"Error opening PDF: {e}")
            return None

    def visitLossExpr(self, ctx):
        arg = self.visit(ctx.expr()) if ctx.expr() else self.omega
        theta = 1.0
        cost = 0.5
        loss = theta - cost
        self.log(f"loss({arg}) = {loss}")
        return loss
    
    def visitStepExpr(self, ctx):
        arg = self.visit(ctx.expr()) if ctx.expr() else self.omega
        self.log(f"step({arg})")
        return arg
    
    def visitIterateExpr(self, ctx):
        # iterate(expr, N)
        children = list(ctx.getChildren())
        if len(children) >= 4:  # iterate ( expr , NUMBER )
            body = self.visit(children[2])
            n = int(children[4].getText()) if len(children) > 4 else 1
            result = body
            for _ in range(n):
                result = body  # Would need actual iteration logic per use case
            self.log(f"iterate({body}, {n})")
            return result
        return self.omega
    
    def visitIfExpr(self, ctx):
        """if expr then expr else expr"""
        children = list(ctx.getChildren())
        # Structure: if cond then thenExpr else elseExpr
        # or: if cond then thenExpr elifChain else elseExpr
        cond = None
        then_expr = None
        else_expr = None
        
        i = 0
        while i < len(children):
            child = children[i]
            text = child.getText() if hasattr(child, 'getText') else str(child)
            if text == 'if':
                i += 1
                cond = self.visit(children[i])
            elif text == 'then':
                i += 1
                then_expr = self.visit(children[i])
            elif text == 'else':
                i += 1
                else_expr = self.visit(children[i])
            i += 1
        
        # Evaluate condition
        if cond:
            result = then_expr if cond else else_expr
            self.log(f"if {cond} then {then_expr} else {else_expr} → {result}")
            return result
        return None
    
    def visitMapExpr(self, ctx):
        """map(collection, function)"""
        children = list(ctx.getChildren())
        if len(children) >= 4:  # map ( expr , expr )
            coll = self.visit(children[2])
            func_expr = children[4] if len(children) > 4 else None
            if isinstance(coll, (list, range)):
                result = [self.visit(func_expr) for _ in coll]
                self.log(f"map over {len(coll)} elements")
                return result
        return []
    
    def visitFoldExpr(self, ctx):
        """fold(collection)"""
        children = list(ctx.getChildren())
        if len(children) >= 3:  # fold ( expr )
            coll = self.visit(children[2])
            if isinstance(coll, (list, tuple)):
                result = sum(coll) if all(isinstance(x, (int, float)) for x in coll) else coll
                self.log(f"fold({coll}) = {result}")
                return result
        return 0
    
    def visitForallExpr(self, ctx):
        """forall x : formula"""
        self.log("forall quantifier (universal)")
        return True  # Placeholder - real logic would check all cases
    
    def visitPipeExpr(self, ctx):
        """expr |> f"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            left = self.visit(children[0])
            right = self.visit(children[2])
            self.log(f"{left} |> {right}")
            # Pipe: apply right to left
            if callable(right):
                return right(left)
            return right  # If right is not callable, just return it
        return None
    
    def visitDualSymmetryStmt(self, ctx):
        self.log("DualSymmetry applied")
        return self.omega
    
    # =========================================================
    # §2 CGT Redundancy Reduction (o6, o7, o9)
    # =========================================================
    
    def visitQuotientExpr(self, ctx):
        """o6: Redundancy Reduction - Ω / ~"""
        children = list(ctx.getChildren())
        if len(children) >= 4:
            expr_val = self.visit(children[2])
            equiv = children[4].getText() if len(children) > 4 else '~'
            self.log(f"quotient({expr_val}, {equiv})")
            # Return equivalence class representative
            if isinstance(expr_val, (list, tuple)):
                return list(set(expr_val))
            return expr_val
        return self.omega
    
    def visitOrbitExpr(self, ctx):
        """o7: Symmetry Reduction - Ω / G"""
        children = list(ctx.getChildren())
        if len(children) >= 4:
            expr_val = self.visit(children[2])
            group = children[4].getText() if len(children) > 4 else 'G'
            self.log(f"orbit({expr_val}, {group})")
            return expr_val
        return self.omega
    
    def visitSimplifyExpr(self, ctx):
        """o9: Complexity Reduction - C(Ω) ≥ C(Ω')"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"simplify({expr_val})")
            return expr_val
        return self.omega
    
    # =========================================================
    # §3 Canonical Forms (o11, o13, o14)
    # =========================================================
    
    def visitComposeExpr(self, ctx):
        """o11: Complex Associativity - composition"""
        if ctx.exprList():
            exprs = [self.visit(e) for e in ctx.exprList().expr()]
            self.log(f"compose({exprs})")
            # Compose functions left to right
            result = exprs[0] if exprs else None
            return result
        return None
    
    def visitMatchExpr(self, ctx):
        """o14: Canonical Selection - pattern matching"""
        expr_val = self.visit(ctx.expr())
        # Visit match cases
        if ctx.matchCases():
            for case_ctx in ctx.matchCases().matchCase():
                pattern = case_ctx.pattern()
                # Simple pattern matching
                pat_text = pattern.getText()
                if pat_text == '_' or pat_text == str(expr_val):
                    return self.visit(case_ctx.expr())
        return expr_val
    
    # =========================================================
    # §4 Goodness Evaluation (o15-o24)
    # =========================================================
    
    def visitConvergeExpr(self, ctx):
        """o15: Reflective Convergence - lim θ_n(ω) - C_n"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"converge({expr_val})")
            return expr_val
        return self.omega
    
    def visitEntropyExpr(self, ctx):
        """o16: Entropy/Normalization - H(Ω)"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            # Compute entropy if list of probabilities
            if isinstance(expr_val, (list, tuple)):
                import math
                total = sum(expr_val) if expr_val else 1
                probs = [x/total for x in expr_val if x > 0]
                entropy = -sum(p * math.log(p) for p in probs) if probs else 0
                self.log(f"entropy({expr_val}) = {entropy}")
                return entropy
            return 0
        return 0
    
    def visitNonlinearExpr(self, ctx):
        """o18: Nonlinear Logic - ω' := nonlinear(ω)"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"nonlinear({expr_val})")
            return expr_val
        return self.omega
    
    def visitHyperrealExpr(self, ctx):
        """o19: Hyperreal Extension - ω + ε"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            epsilon = 1e-10
            if isinstance(expr_val, (int, float)):
                result = expr_val + epsilon
                self.log(f"infinitesimal({expr_val}) = {result}")
                return result
        return self.omega
    
    def visitDimensionExpr(self, ctx):
        """o20: Dimensional Consistency"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"dim({expr_val})")
            # Return dimensionality
            if isinstance(expr_val, (list, tuple)):
                return len(expr_val)
            return 1
        return 1
    
    def visitGoodnessExpr(self, ctx):
        """o21: Goodness Function - G := θ(Ω) - C"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            theta = 1.0
            cost = 0.5
            goodness = theta - cost
            self.log(f"goodness({expr_val}) = {goodness}")
            return goodness
        return 0.5
    
    def visitPreserveExpr(self, ctx):
        """o22: Information Preservation - I(Ω) = I(T(Ω))"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"preserve({expr_val})")
            return expr_val
        return self.omega
    
    def visitEnergyExpr(self, ctx):
        """o23: Energy Efficiency - E(Ω)"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            # Compute energy as sum of squares
            if isinstance(expr_val, (list, tuple)):
                energy = sum(x**2 for x in expr_val if isinstance(x, (int, float)))
                self.log(f"energy({expr_val}) = {energy}")
                return energy
            return 0
        return 0
    
    def visitDivergeExpr(self, ctx):
        """o24: Chaotic Creativity - diverge"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"diverge({expr_val})")
            return expr_val
        return self.omega
    
    # =========================================================
    # §5 FFA Optimization (o25-o40)
    # =========================================================
    
    def visitGradientExpr(self, ctx):
        """o25: Gradient Flow - dω/dt = -∇L(ω)"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"gradient({expr_val})")
            # Return numerical gradient approximation
            if isinstance(expr_val, (int, float)):
                return -0.1 * expr_val  # Simple gradient descent
            return expr_val
        return 0
    
    def visitDynamicsExpr(self, ctx):
        """o26: Dynamical System - dω/dt = f(ω)"""
        children = list(ctx.getChildren())
        if len(children) >= 4:
            state = self.visit(children[2])
            time = self.visit(children[4]) if len(children) > 4 else 1
            self.log(f"evolve({state}, {time})")
            return state
        return self.omega
    
    def visitProbExpr(self, ctx):
        """o28: Probabilistic - P(ω' | ω)"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            # Check for conditional
            for i, c in enumerate(children):
                if hasattr(c, 'getText') and c.getText() == '|':
                    given = self.visit(children[i + 1]) if i + 1 < len(children) else None
                    self.log(f"P({expr_val} | {given})")
                    return 0.5  # Placeholder probability
            self.log(f"P({expr_val})")
            return 0.5
        return 0.5
    
    def visitStabilizeExpr(self, ctx):
        """o30: Self-Regulation - stabilize"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"stabilize({expr_val})")
            return expr_val
        return self.omega
    
    def visitTransformOp(self, ctx):
        """o31: Base Transform - transform(omega, f)"""
        children = list(ctx.getChildren())
        if len(children) >= 4:
            omega_val = self.visit(children[2])
            func = self.visit(children[4]) if len(children) > 4 else None
            self.log(f"transform({omega_val}, {func})")
            return omega_val
        return self.omega
    
    def visitPathExpr(self, ctx):
        """o32: Path Dependence - Ω(t) = f(T(t), Ω₀)"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"path({expr_val})")
            return expr_val
        return self.omega
    
    def visitFluxExpr(self, ctx):
        """o34: Non-Equilibrium Dynamics"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"flux({expr_val})")
            return expr_val
        return self.omega
    
    def visitCausalExpr(self, ctx):
        """o35: Causality - Ω(t) = C(Ω(t-1))"""
        children = list(ctx.getChildren())
        if len(children) >= 4:
            effect = self.visit(children[2])
            cause = self.visit(children[4]) if len(children) > 4 else None
            self.log(f"cause({effect}, {cause})")
            return effect
        return self.omega
    
    def visitOptimizeExpr(self, ctx):
        """o37: Student Supremacy - optimize"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"optimize({expr_val})")
            return expr_val
        return self.omega
    
    def visitLineageExpr(self, ctx):
        """o38: Recursive Lineage"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"lineage({expr_val})")
            return expr_val
        return self.omega
    
    def visitEmergeExpr(self, ctx):
        """o39: Internal Emergence"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"emerge({expr_val})")
            return expr_val
        return self.omega
    
    def visitDualExpr(self, ctx):
        """o40: Conjugate Duality - ω† := C(ω)"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"dual({expr_val})")
            # Return conjugate
            if isinstance(expr_val, complex):
                return expr_val.conjugate()
            return expr_val
        return self.omega
    
    # =========================================================
    # Let Bindings (o12)
    # =========================================================
    
    def visitLetExpr(self, ctx):
        """o12: Contextual Monoid - let...in scoped bindings"""
        if ctx.letBinding():
            binding = ctx.letBinding()
            name = binding.IDENT().getText()
            val = self.visit(binding.expr())
            
            # Save old env, bind, evaluate body, restore
            old_env = self.env.copy()
            self.env[name] = val
            
            # Body is the last expr
            body_ctx = ctx.expr()[-1] if hasattr(ctx, 'expr') and ctx.expr() else None
            result = self.visit(body_ctx) if body_ctx else val
            
            self.env = old_env
            self.log(f"let {name} = {val} in ... = {result}")
            return result
        return None
    
    def visitLetRecExpr(self, ctx):
        """o27/o33: Recursive bindings - let rec"""
        if ctx.recBindingList():
            for binding in ctx.recBindingList().recBinding():
                name = binding.IDENT().getText()
                # For recursive functions, we need to bind first
                self.functions[name] = binding
                self.log(f"let rec {name} defined")
        
        # Evaluate body
        body_ctx = ctx.expr()
        return self.visit(body_ctx) if body_ctx else None
    
    # =========================================================
    # Try/Raise (o8, o17)
    # =========================================================
    
    def visitTryExpr(self, ctx):
        """o17: Self-Correction - try...with"""
        try:
            return self.visit(ctx.expr())
        except Exception as e:
            self.log(f"Exception caught: {e}")
            # Try to find matching case
            if ctx.matchCases():
                for case_ctx in ctx.matchCases().matchCase():
                    return self.visit(case_ctx.expr())
            return None
    
    def visitRaiseExpr(self, ctx):
        """o8: Symmetry Breaking - raise exception"""
        expr_val = self.visit(ctx.expr())
        self.log(f"raise {expr_val}")
        raise RuntimeError(str(expr_val))
    
    # =========================================================
    # Lambda Expressions
    # =========================================================
    
    def visitLambdaExpr(self, ctx):
        """Lambda abstraction"""
        # Get parameter name
        param = ctx.IDENT().getText() if ctx.IDENT() else 'x'
        body_ctx = ctx.expr()
        
        # Create a closure
        def closure(arg):
            old_env = self.env.copy()
            self.env[param] = arg
            result = self.visit(body_ctx)
            self.env = old_env
            return result
        
        self.log(f"λ{param}. ...")
        return closure
    
    # =========================================================
    # Record Expressions
    # =========================================================
    
    def visitRecordExpr(self, ctx):
        """Record/object literal"""
        result = {}
        if ctx.fieldList():
            for field_ctx in ctx.fieldList().field():
                name = field_ctx.IDENT().getText()
                val = self.visit(field_ctx.expr())
                result[name] = val
        return result
    
    # =========================================================
    # Tuple Expressions
    # =========================================================
    
    def visitTupleExpr(self, ctx):
        """Tuple literal"""
        if ctx.exprList():
            return tuple(self.visit(e) for e in ctx.exprList().expr())
        elif ctx.expr():
            return (self.visit(ctx.expr()),)
        return ()
    
    # =========================================================
    # Set Comprehension
    # =========================================================
    
    def visitSetComprehension(self, ctx):
        """Set comprehension {x | P(x)}"""
        # This requires the collection and predicate
        self.log("set comprehension")
        return set()
    
    # =========================================================
    # Theta Expressions
    # =========================================================
    
    def visitThetaExpr(self, ctx):
        """Reflectology theta function"""
        children = list(ctx.getChildren())
        if len(children) >= 3:
            expr_val = self.visit(children[2])
            self.log(f"theta({expr_val})")
            # Return goodness value
            return 1.0
        return 1.0
    
    # =========================================================
    # IO Operations
    # =========================================================
    
    def visitIoDecl(self, ctx):
        """IO declaration"""
        name = ctx.IDENT().getText()
        io_val = self.visit(ctx.ioExpr())
        self.env[name] = io_val
        self.log(f"io {name} = {io_val}")
        return io_val
    
    def visitIoExpr(self, ctx):
        """IO expression"""
        children = list(ctx.getChildren())
        if children:
            op = children[0].getText() if hasattr(children[0], 'getText') else ''
            if op == 'read' and len(children) >= 3:
                ident = children[2].getText()
                return self.env.get(ident, None)
            elif op == 'write' and len(children) >= 5:
                ident = children[2].getText()
                val = self.visit(children[4])
                self.env[ident] = val
                return val
            elif op == 'return' and len(children) >= 3:
                return self.visit(children[2])
            elif op == 'error' and len(children) >= 3:
                msg = children[2].getText().strip('"\'')
                self.log(f"Error: {msg}")
                return None
        return None
    
    # =========================================================
    # NLP/Regex Operations
    # =========================================================
    
    def visitPatternMatchStmt(self, ctx):
        """NLP pattern matching"""
        expr_val = self.visit(ctx.expr())
        pattern = ctx.pattern().getText() if ctx.pattern() else ''
        self.log(f"pattern_match({expr_val}, {pattern})")
        return expr_val
    
    def visitRegexMatchStmt(self, ctx):
        """Regex matching"""
        import re
        expr_val = str(self.visit(ctx.expr()))
        pattern = ctx.pattern().getText() if ctx.pattern() else ''
        try:
            match = re.search(pattern, expr_val)
            return match.group(0) if match else None
        except:
            return None
    
    def visitRegexReplaceStmt(self, ctx):
        """Regex replace"""
        import re
        exprs = [self.visit(e) for e in ctx.expr()]
        if len(exprs) >= 2:
            text = str(exprs[0])
            replacement = str(exprs[1])
            pattern = ctx.pattern().getText() if ctx.pattern() else ''
            try:
                return re.sub(pattern, replacement, text)
            except:
                return text
        return ''
    
    # =========================================================
    # ABI/API/FFI
    # =========================================================
    
    def visitFfiCall(self, ctx):
        """FFI call"""
        children = list(ctx.getChildren())
        if len(children) >= 5:
            lib = children[2].getText().strip('"\'')
            func = children[4].getText().strip('"\'')
            self.log(f"ffi_call({lib}, {func})")
            return None
        return None
    
    # =========================================================
    # Matrix Operations
    # =========================================================
    
    def visitMatrixLiteral(self, ctx):
        """Matrix literal [rows]"""
        if ctx.matrixRows():
            rows = []
            for row_ctx in ctx.matrixRows().matrixRow():
                row = [self.visit(e) for e in row_ctx.exprList().expr()]
                rows.append(row)
            return rows
        return []
    
    def visitMatrixMul(self, ctx):
        """Matrix multiplication @@"""
        left = self.visit(ctx.expr(0))
        right = self.visit(ctx.expr(1))
        if isinstance(left, list) and isinstance(right, list):
            # Simple matrix multiply
            try:
                result = [[sum(a*b for a,b in zip(row, col)) 
                          for col in zip(*right)] for row in left]
                return result
            except:
                pass
        return []
    
    # =========================================================
    # Import/Export
    # =========================================================
    
    def visitExportStmt(self, ctx):
        """Export to format"""
        expr_val = self.visit(ctx.expr())
        children = [c.getText() for c in ctx.STRING()]
        path = children[0].strip('"\'') if children else ''
        fmt = children[1].strip('"\'') if len(children) > 1 else ''
        self.log(f"export {expr_val} to {path} as {fmt}")
        return expr_val
    
    def visitImportStmt(self, ctx):
        """Import from format"""
        children = [c.getText() for c in ctx.STRING()]
        path = children[0].strip('"\'') if children else ''
        fmt = children[1].strip('"\'') if len(children) > 1 else ''
        self.log(f"import from {path} as {fmt}")
        return None


def run_file(filepath, proof_mode=False):
    """Parse and execute a .mdld file"""
    if not proof_mode:
        print(f"\n{'=' * 60}")
        print(f"EXECUTING: {filepath}")
        print(f"{'=' * 60}")
    
    with open(filepath) as f:
        code = f.read().rstrip('\n')
    
    lexer = mdldLexer(InputStream(code))
    stream = CommonTokenStream(lexer)
    parser = mdldParser(stream)
    tree = parser.document()
    
    interpreter = MdldInterpreter(proof_mode=proof_mode)
    result = interpreter.visit(tree)
    
    if proof_mode:
        # Output Metamath proof
        proof_output = interpreter.proof_gen.generate(filepath)
        print(proof_output)
    else:
        print(f"\n{'─' * 60}")
        print(f"Environment: {interpreter.env}")
        print(f"Functions: {list(interpreter.functions.keys())}")
        print(f"Modules: {list(interpreter.modules.keys())}")
        print(f"Final Ω: {interpreter.omega}")
        print(f"{'=' * 60}")
    
    return interpreter


if __name__ == "__main__":
    import os
    import sys
    
    proof_mode = '--proof' in sys.argv
    args = [a for a in sys.argv[1:] if a != '--proof']
    
    if args:
        # Run specified file
        run_file(args[0], proof_mode=proof_mode)
    else:
        # Default: run ring0 and ring3 as demo
        rings_dir = "rings"
        run_file(os.path.join(rings_dir, "ring0_kernel.mdld"), proof_mode=proof_mode)
        run_file(os.path.join(rings_dir, "ring3_analysis.mdld"), proof_mode=proof_mode)
